------
О BASH:
-------

Bash (от англ. bourne-again shell – «возрожденная» оболочка Борна).

Версии:
-------
sh - Bourne Shell, 1978
csh - C Shell, 1979 - имеет ряд улучшений, не имеет обратной совместимости с sh.
ksh - Korn Shell, 1983 - включает возможности C Shell, обратно совместим с sh.
bash - Bourne again Shell, 1989 - разработана в рамках GNU, в качестве усовершенствованной sh.

Исполняемый файл оболочки хранится в: /bin/bash
Данные о текущей оболочке (по умолчанию) хранятся в переменной $SHELL.
#Можно сменить текущую оболочку сменив значение переменной:
	export SHELL=/bin/bash
	!!!Присвоенное значение будет актуально, только в рамках текущей терминальной сессии
		и дочерних!!!
#Посмотреть PID текущего процесса shell:
	echo $$

Строка-приглашения:
-------------------
Строка с которой начинается работа в оболочке, показывает пользователю что готова принимать его команды.

Настройки строки-приглашения хранятся в переменной $PS1
#Посмотреть настройки можно командой:
	echo $PS1

#Настроить сроку-приглашения можно, присвоив значение переменной:
	export PS1="ПАРАМЕТРЫ_СТРОКИ" 

	#Параметры заполняются друг за другом,
		пробелы и неэкранированные спецсимволы воспринимаются как часть текста
		в строке приглашения.

Настройки строки-приглашения
----------------------------

Конфигурация приглашения Bash хранится в файле .bashrc вашей учетной записи, который находится в ~/.bashrc

Биты опций (параметры приглашения):

\n		#Перевод последующего текста на новую строку
\d		#Дата в формате «День недели Месяц Число»
\D{format}	#Дата указанного формата
\A		#Время в 24-часовом формате
\t		#Текущее время в 24-часовом формате «HH.MM.SS»
\T		#Время в 12-часовом формате
\@		#Время в формате 12 часов утра / вечера
\l		#имя устройства терминала
\s		#Имя оболочки
\v		#Версия оболочки bash
\V		#Выпуск Bash, версия + уровень исправления
\h		#Имя хоста до первого символа точка «.»
\H		#Имя хоста
\u		#Имя пользователя
\W		#Текущий относительный путь. Домашняя директория сокращается до значка “~”
\j		#Количество фоновых процессов, запущенных в данной оболочке
\[ или \]	#Начало \ конец последовательности непечатаемых символов
\$		#Символ приглашения ($ для обычных пользователей, # для суперпользователя)
\!		#Номер истории этой команды
\#		#Номер команды этой команды
\nnn		#Cимвол, чей ASCII-код является восьмеричным значением nnn
\\		#Обратная косая черта
`КОМАНДА`	#Вывести результат выполнения команды в приглашение

Добавить цвета в Bash Prompt:
-----------------------------
Цвета указываются перед битами опций

\] character \[ и \] character	#Общая схема тега	
\033[ или \e[			#Показывает bash что здесь задается цвет
m\				#Указывается в конце тега


!!!Больше символов можно найти в разделе “PROMPTING” внутри man документации по bash!!!

Горячие клавиши bash:
---------------------

*** clear		#очистить экран

Работа с командами в bash:
--------------------------

Большинство команд могут использоваться с уточняющими параметрами.
Первый из параметров – это ключ (или флаг), ему предшествует один или два знака минуса.
	Ключи модифицируют работу программы.
Второй параметр – это аргументы, над которыми выполняется команда.

#Конструкция команд:
	команда -ключ аргумент_1 аргумент_2 …


Стандартные потоки ввода вывода:
--------------------------------

В системе стандартно используется 3 потока:
	один для чтения символов (in=0), второй для вывода символов (out=1) и третий для ошибок (err=2).

Мы можем направлять поток вывода на стандартное устройство
	- вывод в консоль, можем одновременно выводить в консоль и в файл, а также можем направлять поток вывода одной команды на поток ввода другой.

Для того, чтобы направить поток вывода одной команды на поток ввода другой используют символ "|":

$ echo 'some text' | wc

 

----------------------
СПРАВОЧНАЯ ИНВОРМАЦИЯ:
----------------------

*** man		#форматирование и отображение интерактивных страниц руководства;
	ИМЯ_КОМАНДЫ

--------------
ПОИСК В LINUX:
--------------

Поиск программ:
---------------
	
*** whereis ИМЯ_ПРОГРАММЫ			#Вывод размещения программ;
	echo $PATH				#Покажет все пути поиска программ в системе;
	PATH=$PATH:ПУТЬ			#Позволяет добавить локацию переменную PATH;

***  which ИМЯ_ПРОГРАММЫ			#Проверить пути до программы в переменной PATH;

Поиск файлов:
-------------

*** find ПУТЬ -name ИМЯ_ФАЙЛА			#Найти файл в указанной директории;
	-iregex:'РЕГУЛЯРНОЕ_ВЫРАЖЕНИЕ'		#Можно использовать регулярные выражения;
						!!!Для поиска с помощью регулярных выражений очень важно добавить сочетание .* вначале,
							потому что команда find требует указание абсолютного пути для регулярных выражений!!!
	ИМЯ_ФАЙЛА\*				#После имени предполагает наличие любого расширения файла;
	-size <РАЗМЕР>				#Поиск по размеру файла.
							c - байты, k - килобайты, b - 512 байтные блоки, w - 2 байтные слова.
							Указав перед параметром + или - можно искать файл размером более или менее указанной величины:	
	-type <ТИП>				#f - обычный файл, d - директория, l - ссылка, s - сокет.
#Пример:
	find /User/user_1/Documents  -type f -size +40k					

--------------------
НАВИГАЦИЯ ПО СИСТЕМЕ
--------------------

Где я?
------

*** pwd			#Напечатать рабочую (текущую) директорию;

Перемещение:
------------

*** cd			#сменить директорию;
	ИМЯ_ПАПКИ
			#Без параметров "переносит" в домашнюю директорию текущего пользователя, тоже делают параметры:
	~
	~/
	..		#Перемещение на уровень выше;
	-		#Перемещение в предыдущую папку;
	.		#Просто текущая директория;
	/		#Корневой каталог;
 	/bin		#Каталог, содержащий исполняемые модули командной строки (бинарные файлы);
	/dev		#Каталог для хранения специальных файлов (Файлов устройств);
	/etc		#Здесь содержатся исполняемые файлы и файлы системной конфигурации;
	/lib		#Каталог, хранящий бибилиотеки компилятора языка С/.
	/var/log/	#Обычно системные "log-файлы" находятся здесь;

	
----------------------
РАБОТА С ДИРЕКТОРИЯМИ:
----------------------

*** ls				#Просмотр содержимого директории;
	ИМЯ_ДИРЕКТОРИИ
	-a			#Добавить в вывод системные (скрытые) файлы и директории;
	-l			#Вывести содержимое списком (подробные сведения в нескольких столбцах);
					#4 столбец - количество жестких ссылок на файл (hardlink);
		-d		#Подробная информация о каталоге;
	-i			#Показать inode;

*** mkdir ИМЯ_ДИРЕКТОРИИ	#создать директорию;
	-p			#Создать цепочку вложенных каталогов;

					

-----------------
РАБОТА С ФАЙЛАМИ:
-----------------

В UNIX/Linux системах вся информация содержится в файлах.
Каждый файл имеет собственное имя и он может относиться к одному из следующих типов:

1) Обычный файл
2) Каталог
3) Специальный файл (файл устройства)
4) Файл-ссылка

Стоит помнить, что UNIX/Linux системы чувствительны к регистру и имена  "file" и "File" будут абсолютно разными.

При указании имени файлов вы можете использовать строчные и заглавные латинские буквы, цифры, точку "." и нижнее подчеркивание "_".
Символы * ! / [ ] ( ) ; & ^ |   ' " ` { } + - \ и пробел следует избегать в названии файлов, т.к. они имеют специальное значение.

*** touch ИМЯ_ФАЙЛА			#Создать пустой файл, обновить дату файла;


-----------------------------------------------------
КОПИРОВАНИЕ, ПЕРЕМЕЩЕНИЕ, УДАЛЕНИЕ ДИРЕКТОРИЙ/ФАЙЛОВ:
-----------------------------------------------------

*** cp ИСТОЧНИК НАЗНАЧЕНИЕ	#Копировать файл/директорию;	


*** mv ИСТОЧНИК НАЗНАЧЕНИЕ	#переместить/переименовать файл/директорию;


*** rm ИМЯ_ФАЙЛА/ДИРЕКТОРИИ	#Удалить файл/директорию;
	-i			#Удаление в интерактивном режиме - с запросом;
	-f			#Без запроса;
	-r			#Рекурсивно - для удаление "непустых" каталогов;


------------------------
ЖЕСТКИЕ И МЯГКИЕ ССЫЛКИ:
------------------------

Жесткая ссылка (hardlink) - еще одно имя файла/директорию;
	.	- на текущую директорию;
	..	- на родительскую директорию;
	!!!Пользователи не могут создавать жесткие ссылки на директории!!!

Мягкая/символьная ссылка (softlink) - "ярлык" на файл/директорию;
	!!! желательно в мягкой ссылке указывать абсолютный путь к файлу/директории;

*** ln ИМЯ_ФАЙЛА			#создать жесткую ссылку на файл;
	-s				#создать мягкую ссылку на 


-----------------
РАБОТА С ТЕКСТОМ:
-----------------

*** echo		#запись аргументов в стандартный вывод

#Вывод текста на экран:
	echo ТЕКСТ/"ТЕКСТ"

#Записать текст в файл:
	echo ТЕКСТ/"ТЕКСТ" > ИМЯ_ФАЙЛА

#Добавить текст в файл:
	echo ТЕКСТ/"ТЕКСТ" >> ИМЯ_ФАЙЛА

	-n	#отменяет вывод перевода строки - текст помещается перед строкой-приглашением;

*** cat <ИМЯ_ФАЙЛА>		#Вывести на экран содержимое документа;
	> <ИМЯ_ФАЙЛА>		#Печатать в файл с устройства ввода по умолчанию (клавиатура), ctrl+c - завершить ввод и сохранить;
	>> <ИМЯ_ФАЙЛА>		#Добавить в файл с устройства ввода по умолчанию (клавиатура), ctrl+c - завершить ввод и сохранить (возможен выход в бекграунд и возврат - ctrl+z, fg);
	< <ИМЯ_ФАЙЛА>		#Тоже самое, что и без ключей - вывести содержимое документа на экран;
	-n			#Вывести содержимое файла с нумерацией строк;

*** tac		#Вывод содержимого документа на экран - с конца (как cat, только наоборот, ключи cat - не действуют!!!);

*** wc <ИМЯ_ФАЙЛА>		#Вывод количества строк, слов и символов в файле;

*** head <ИМЯ_ФАЙЛА>		#Вывести первые 10 строк файла (с начала);
	-n <ЧИСЛО_СТРОК>		#Вывести указанное количество строк;

*** tail	<ИМЯ_ФАЙЛА>		#Вывод последних 10 строк файла (с конца);
	-n <ЧИСЛО_СТРОК>		#Вывести указанное количество строк;

*** sort <ИМЯ_ФАЙЛА>		#Выводит отсортированный по алфавиту текст;

*** uniq	<ИМЯ_ФАЙЛА>		#Отображает только уникальные строки, т.е. при выводе удаляет повторения (Текст должен быть отсортирован!!!);

*** cut -c<НОМЕР_РАЗДЕЛИТЕЛЯ> <ИМЯ_ФАЙЛА>					#Вывод указанного номера символа из каждой строки документа (или символов);
	-с								#Отсчитывает символы;
	-c<ЧИСЛО>-<ЧИСЛО>						#Можно указывать интервалы;
	-d'<РАЗДЕЛИТЕЛЬ>' -f<НОМЕР_СИМВОЛА+ПОСЛЕ_РАЗДЕЛИТЕЛЯ>		#Указывает по какому разделителю производить срез, если этот разделитель отсутствует в строке,
										тогда будет выведена вся строка;
										-f, указывающий какое поле должно быть отображено после разделения;
	-b<НОМЕР_БАЙТА>							#Производит срез по байтам. Если в файле нет многобайтных символов, то результат будет такой же, как и с флагом -c;

*** less <ИМЯ_ФАЙЛА>			#Постраничный вывод содержимого файла;
	-g<НОМЕР_СТРОКИ>			#Открыть файл с указаной строки, по умолчанию - с первой;

		



AWK				#Язык сканирования и обработки шаблонов
-----

Awk - утилита, сопоставимая с отдельным языком программирования.
Данная утилита позволяет работать с переменными, использовать структурные элементы типа if-else и циклы, а также создавать отчеты. 
Awk работает с файлами, поэтому при обращении к этой команде, она будет ожидать получение файла на вход.

Синтаксис:
	awk '{что_вытащить/сделать}' файл_откуда_вытащить

Например:
	awk '{print "текст"}'			#при каждом нажатии "Enter" будет выводить указанный текст на экран;
	awk '{print $1}' 	имя_файла	#выведет из указанного файла первое слово каждой строки ($0 - вся строка);
		-Fразделитель			#позволяет указать по какому разделителю стоит производить разбиение строки на элементы.
							#Без ключа awk считает разделителем пробел.
	
	echo "bash is awesome" | awk '{$1="python"; print $0}'		#выведет указанный текст на экран заменив первое слово на "python"




Vi/Vim
------				#Текстовый редактор для программистов;
*** vi/vim <ИМЯ_ФАЙЛА>		#Открыть/создать файл с указанным именем;
					!!!Без указания имени запрашивает сохранение и имя при выходе из документа!!!
	Esc			#Выход в режим навигации - перемещение по документу, удаление/копирование/вырезание/вставка текста;
		0		#Переход в начало строки;
		$		#Переход на предпоследний символ текущей строки;
		p		#Вставка содержимого из буфера обмена;
		D		#Удалить
		a		#Переход в режим ввода текста на символ в право
		i		#Переход в интерактивный режим ввода cлева от курсора;
	:			#Из в режиме навигации переход в режим ввода команд;
		w		#Записать/сохранить изменения в документ;
		q		#Выйти из документа;
		!		#Принудительное выполнение введенной команды;

--------------------------------------
РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ (ГЛОБАЛЫ, REGEX):
--------------------------------------

*** grep					#Вывод строк соответствующих шаблону;
	ШАБЛОН ИМЯ_ФАЙЛА		#Обработка данных из файла;
	КОМАНДА | grep ШАБЛОН		#Обработка выходного потока (&1,&2)из предыдущей команды;
					!!!Можно указывать несколько шаблонов подряд!!!
					!!!При этом, будет выводится результат как сочетаний этих шаблонов, так и их отдельное присутствие!!!
					!!!
	
	Пробел				#Разделяет шаблоны.
	\				#Экранирование последующего символа/слитных символов - то, что экранировано - воспринимается как единый текст; 
	Пробел +, ., *, [, ] или \	#Необходимо экранировать, если это должно восприниматься как текст;
	.				#Любой Единичный символ;
	\d или [0-9]			#Любой цифровой символ;
	\D или [^0-9]			#Любой не цифровой символ
	\w				#Любой буквенный, цифровой символ или знак подчеркивания
	\W				#любой символ, кроме букв, цифр, знака подчеркивания;
	\s				#Пробельный символ;
	\S				#Непробельный символ;
	^				#Поиск шаблона в начале;
	$				#Поиск шаблона в конце;
	\b				#Граница слова;
	\B				#Не граница слова;
	''				#Составные шаблоны заключается в кавычки;

*** egrep				#Расширенных grep;

#Данная команда производит поиск с помощью метасимволов и лучше подходит для обработки более сложных регулярных выражений.

	? или {0,1}			#Ноль или одно соответствие одному символу слева;
	* или {0,}			#Ноль и более соответствий;
	+ или {1,}			#Одно и более соответствий;
	{n}				#Ровно n раз;
	[]				#Внутри них перечисляют ряд символов, которые могут стоять на конкретном месте.
						#Внутри квадратных скобок символы читаются буквально и не требуют экранирования;
		[^]				#Исключить символы в скобках из вывода;
	|				#перечисление строк;

-----------
ПЕРЕМЕННЫЕ:
-----------
Переменные - это определенные метки, обозначающие определенное место в памяти, где хранится информация.

Задаются переменные двумя способом - статическим и динамическим.

#Статический способ представляет из себя конструкцию:
	VARIABLE=value		#Текст с пробелами и "не буквенными" символами нужно заключать в кавычки ' ' " "!!!
					Нельзя ставить пробелы между именем!!!

#Динамический способ - предложит ввести информацию, после чего свяжет эту информацию с переменной:
	read ИМЯ_ПЕРЕМЕННОЙ

Используя команду "unset", мы можем уничтожать определение переменных: "unset VAR_1".
При создании переменных, следует помнить, что в названии можно использовать только буквы, цифры и нижнее подчеркивание.
Так же в Bash принято называть переменные используя заглавные буквы.

В языке Bash переменные не имеют типа, поэтому можно считать, что любая информация в переменных являются строками.
Если необходимо интерпретировать переменную как число, тогда необходимо использовать разбор строки с помощью регулярных выражений 

Переменная может быть глобальной или локальной.
Если переменная локальная - она будет доступна только из данного скрипта.

#Вызов переменной (ее значения):
	$ИМЯ_ПЕРЕМЕННОЙ

#Просмотреть значение переменной можно с помощью команды echo:
	echo $ИМЯ_ПЕРЕМЕННОЙ

#Присвоить/Изменить значение переменно можно следующей командой:
	export ИМЯ_ПЕРЕМЕННОЙ=ЗНАЧЕНИЕ_ПЕРЕМЕННОЙ
	!!!Если значение переменной - текстовое (и/или имеет спецсимволы (в.т.ч. пробел) -
		его лучше заключить в "")!!!

#Уничтожить значение переменной:
	unset ИМЯ_ПЕРЕМЕННОЙ

Перечень системных (глобальных) переменных:
------------------------------
	SHELL	#оболочка по умолчанию для текущего пользователя;
	$	#PID процесса текущей оболочки;	
	PS1	#текущие настройки строки приглашения.
	PATH	#Хранит все пути поиска программ в системе;
	IFS	#содержит символы, которые оболочка Bash считает за разделители.
		#По умолчанию это знаки пробела, табуляции и знак перевода строки.
			


---------------
МАССИВЫ ДАННЫХ:
---------------

#Объявление массива:
	ИМЯ_МАССИВА=(ЧИСЛО ЧИСЛО ЧИСЛО "СТРОКА" "СТРОКА")

#Обратиться к массиву и присвоить/добавить его значение переменной:

	ИМЯ_ПЕРЕМЕННОЙ=${ИМЯ_МАССИВА[@]}
		!!!если нужно обратиться к конкретному элементу массива, вместо "@" указываем номер (индекс) элемента - счет идет от "0"
 

дополнительные операции с переменными:
--------------------------------------

	${#VAR}			возвращает количество символов(длину) значения переменной.
	${#array[@]}		размер массива.
	${VAR:pos}		подстрока с позиции pos
	${VAR:pos:len}		подстрока с позиции pos длинной length
	${VAR?err_msg}		проверяет, если VAR определена, то ее значение возвращается, иначе печать err_msg
	${!arr[@]}		получение индексов массива
	arr[0]=value		перезапись первого элемента массива
	arr+=(value)		присоединение к массиву значения
	str=$(ls)		cохранение вывода команды ls в виде строки
	${arr[@]:s:n}		получение элементов массива начиная с элемента с индексом s до элемента с индексом s+(n-1).


----------------
СКРИПТЫ НА BASH:
----------------

Язык Bash относится к командно-сценарным языкам программирования.
Последовательность команд, записанная в один файл называется сценарием или скриптом.
Скрипты создаются для автоматического выполнения задачи.
Bash-файлы имеют расширение ".sh"

Каждый sh скрипт начинается со строки, которая называется "shebang" - она показывает системе, что данный исполняемый файл выполняется с помощью оболочки bash:
	#!/bin/bash

Текст комментариев в одну строку записывается после знака "#" вначале строки:
	#ТЕКСТ_КОММЕНТАРИЯ
	#ТЕКСТ_КОММЕНТАРИЯ
	...

Когда скрипт завершает свою работу, он передает родительской оболочке информацию о завершении.
Обычно статусом о завершении является результат выполнения последней команды,
	однако вы можете в конце скрипта добавить строку "exit 0", которая будет сообщать об успешном завершении скрипта.


Конструкция арифметических выражений:
-------------------------------------

С точки зрения арифметики, Bash ничем не отличается от других языков и имеет набор стандартных операторов (+, -, /, *, %, **).

Bash позволяет использовать привычные операторы сравнения и действия, и имеет свои особенности:

Во первых, внутри арифметической конструкции мы можем обращаться к переменным без символа "$".
Во вторых, мы можем использовать эту конструкцию самостоятельно для изменения значения переменных.

Общий вид:

(( a ДЕЙСТВИЕ_СРАВНЕНИЕ b ))


операторы для сравнения чисел:
------------------------------

Оператор	Значение
	-gt	#Больше (>)
	-lt	#Меньше (<)
	-ge	#Больше или равно (>=)
	-le	#Меньше или равно (<=)
	-eq	#Равно (==)
	-ne	#Не равно (!=)


Дополнительные математические действия:
---------------------------------------

Проверка числа на четность:
	VAR % 2 == 1

УСЛОВНЫЕ КОНСТРУКЦИИ:
---------------------

В Bash имеются операторы для создания условных конструкций типа if-else.
Условные конструкции нужны для того, чтобы скрипт мог иметь несколько вариантов развития, в зависимости от условий.
Суть условных конструкций можно кратко изложить следующим образом: проверка команд на успешное выполнение.

С помощью оператора "if" мы начинаем нашу условную конструкцию.
После оператора  "if" должна идти команда. Как мы уже знаем, команда после выполнения передает значение об успешности выполнения (0 или 1).
0 соответствует успешному выполнению команды. Если команда выполнена успешно, тогда продолжает работу оператор "then".
Система начинает выполнять команды, написанные после оператора "then".
Если команда завершается неуспешно, тогда все инструкции, относящиеся к данному "then" игнорируются и происходит переход к оператору "elif".
Elif это сокращение от else-if. Затем снова проверяется команда, между elif и then.
Если она также имеет статус выполнения 1, тогда выполняются все инструкции, написанные после else.
Завершением условной конструкции является оператор "fi".

Общий вид:

	if [ УСЛОВИЕ_ИСТИННОСТИ ]; then
		ДЕЙСТВИЕ_ПРИ_СОБЛЮДЕНИИ_УСЛОВИЯ
	elif [ НОВОЕ_УСЛОВИЕ_ИСТИННОСТИ ]; then
		ДЕЙСТВИЕ_ПРИ_СОБЛЮДЕНИИ_НОВОГО_УСЛОВИЯ
	else
		ДЕЙСТВИЕ_ИНАЧЕ
	fi

В данном случае "[" является командой на получение аргументов, а "]" команда на завершение процесса получения аргументов.
В качестве аргументов может выступать любая другая команда, например ls.
В результате мы получим 0 или 1, которая позволит идти нам дальше по логической цепочке.
Т.к. "[ ]" является командой, то важно ставить отступы аргументов от "[" и "]".
Знак ";" ставится для разграничения операторов, стоящих на одной строке. 

Если не заключать команду-условие в квадратные скобки "[]", то вывод команды будет произведен в консоль.

Существует еще одна конструкция, которая в целом работает также, как и команда "[]", однако лучше подходит для регулярных выражений:

[[ REGEX ]]

Конструкция "[[]]" появилась в версии Bash 2.02 и является более предпочтительной, нежели команда "[]".
Например, конструкция "[[]]" воспринимает логические операторы (&&, ||, >, <).
Использование логических операторов в команде "[]" порождает ошибки.


ЦИКЛЫ:
------

Циклы - это управляющие конструкции, которые позволяют выполнять повторяющиеся действия.
Циклы могут быть вложены друг в друга.

Как и в других языках, в Bash имеются 2 основных цикла: for и while.

*** FOR

Данный цикл производит перебор значений из некоторой последовательности.
В переменную последовательно подставляется каждое значение из последовательности и выполняются инструкции из набора команд.
После этого подставляется следующее значение и так до тех пор, пока не произойдет перебор по всем значениям.

Базовая конструкция цикла выглядит следующим образом:

	for [ПЕРЕМЕННАЯ] in [ПОСЛЕДОВАТЕЛЬНОСТЬ_ЗНАЧЕНИЙ]
		do
			[НАБОР_КОМАНД]
		done

С помощью синтаксической конструкции "$()" можно использовать результат некоторых команд в качестве последовательности значений:
Если в результате выполнения команды ожидается строка из нескольких слов, то переменная получит слова каждой строки раздельно
	(т. е. построчного прочтения не будет!!!).

Причина этой особенности кроется в переменной окружения, которая называется "IFS".
Данная переменная содержит символы, которые оболочка Bash считает за разделители.
По умолчанию это знак пробела, табуляции и знак перевода строки.
Соответственно, как только оболочка встречает один из этих символов, происходит разделение строки.
Временным решением для текущей оболочки можно изменить переменную (например вначале скрипта),
	чтобы оболочка считала окончанием строки конкретный символ (например знак перевода строки  \n):

	IFS=$'\n'

Существует вариант записи цикла похожий на язык C:

	for (( i=1; i<=5; i++))
		do
			echo $i
		done



*** WHILE

Производит проверку некоторого условия и выполняет итерации до тех пор, пока данное условие не будет выполнено. 
При работе с данным циклом важно следить, чтобы проверяемое условие выполнялось,
	иначе работа цикла будет производиться до тех пор, пока процесс не займет всю память в системе!!!

Общий вид:

	while [[ УСЛОВИЕ ]]
	do
		ДЕЙСТВИЕ
		ДЕЙСТВИЕ
	done


*** BREAK/CONTINUE

Обеспечивает прекращение выполнения цикла на определённом этапе.

Например, применение break:

	for VAR in ЗНАЧЕНИЯ; do
		ДЕЙСТВИЕ
		if УСЛОВИЕ; then
		break; fi
	done

Команда "continue" похожа на "break",
	только с ее помощью можно пропускать инструкции и переходить к следующей итерации цикла:

	for VAR in ЗНАЧЕНИЯ; do
		if УСЛОВИЕ; then
		continue; fi
		ДЕЙСТВИЕ
	done	


--------
ФУНКЦИИ:
--------

Язык Bash позовляет избежать ситуации, когда при написании скриптов повторяются одинаковые фрагменты кода, с помощью функций. Это особые конструкции, которые содержат в себе часть инструкций. Они позволяют использовать один и тот же код в нескольких местах более компактно для скриптов.

Функции записываются следующим образом:
---------------------------------------

	function funcName {

		ИНСТРУКЦИИ
	}

Для того, чтобы инструкции выполнялись необходимо вызвать функцию по ее имени.

С помощью команды "return" мы можем возвращать из функции целочисленный код завершения работы
	(по аналогии с кодом, который возвращают команды):

	myFunc
	echo "Result of myFunc: $?"

Стотит отметить, что максимальное значение, которое может вернуть команда "return" = 255.
Для того, чтобы обойти данное ограничение, мы можем выводить результат функции в переменную:

	result=$( myFunc )
	echo "Result of myFunc: $result"

-------------------------
РАБОТА С ПРАВАМИ ДОСТУПА:
-------------------------

Каждому файлу и каждой директории присваиваются стандартные права доступа (на работу с объектом):
TUGO
	где:
		T - тип объекта:
			d - директория;
			- - просто файл;
			l - мягкая ссылка (softlink);
		U - права для пользователя-владельца (User);
		G - права на группу пользователя-владельца(Group);
		O - права для всех остальных(Other);
		A - вообще все (All) - применяется только при ручном назначении прав;

Права делятся на три группы по три типа доступа:
		r-- = 100 = 4 - чтение (read);
		-w- = 010 = 2 - запись (write);
		--x = 001 = 1 - исполнение (execute) - необходимо для доступа к каталогу (даде чтение), и для запуска исполняемых файлов;
		--- = 000 - прав нет;

2 и 3 столбцы в "ls -l" - владелец (U) и группа владельца (G);

*** chmod		#смена владельца/группы владельца;
	ПРАВА ФАЙЛ/ДИРЕКТОРИЯ

#Права назначаются буквами или цифрами:
	7 = rwx;
	6 = rw-;	
	5 = r-x;	
	4 = r--;
	3 = -wx;	
	2 = -w-;
	1 = --x;
	#Можно указать цифрами для каждой группы или показать для кого что добавить (убрать) с помощью знаков:
	(u/g/o/a)(+/-)(r/w/x);

*** umask				#Получить или назначить маску прав доступа при создании файла;
					#Выполнив команду umask мы получим код, который вычитается из кода полного доступа;
					#Для директорий это - 777, для файлов - 666;

----------------------
УПРАВЛЕНИЕ АККАУНТАМИ:
----------------------

Перечень учетных записей в системе содержится в файле:
	/etc/passwd
	
	Файл содержит список пользователей, разделенный на несколько полей символом ":".
	Строка с данными по каждому пользователю включает следующие поля:
		имя_пользователя:пароль:UID:GUID:описание:home_dir:shell

	В реальной жизни данный файл содержит более одной строчки.
	Большая часть записей относится к компонентам системы, которые используют отдельные аккаунты для внутрисистемного пользования.
	Для них характерна запись в последнем поле /bin/sh/false.
	Это означает, что данные компоненты ничего не делают, а только выходят из оболочки.
	Данный подход позволяет препятствовать вход в систему из под внутрисистемных компонентов.

Перечень групп пользователей в системе содержится в файле:
		/etc/group

		В нем расположена информация о группах пользователей.
		Включает поля:
			имя_группы:пароль(если_есть):guid:входящие_пользователи


-------------------------------------------
УСТАНОВКА И УДАЛЕНИЕ ПРОГРАММ И ОБНОВЛЕНИЙ:
-------------------------------------------

Работа с APT:
-------------
Система управления программными пакетами "APT" (от англ. Advanced Packaging Tool).
Используется по умолчанию в Debian-дистрибутивах.

Система APT состоит из нескольких утилит. Пример наиболее часто используемой утилиты: apt-get.
Её особенность в том, что она автоматически определяет зависимости между пакетами
	(уже установленными и устанавливаемыми) и следит за корректным процессом установки,
	обновления или удаления пакетов.
Данная утилита обращается к известным ей репозиторием для поиска и скачивания необходимых пакетов.
При этом список репозиториев можно менять.

#Обновление информации в репозиториях:
	apt-get update

#Поиск по имени и описанию пакета во внутреннем кэше:
	apt-cache search ИМЯ_ПАКЕТА

#Установка (обновление уже установленного) пакета:
	apt-get install ИМЯ_ПАКЕТА

#Удаление установленных пакетов:
	apt-get remove ИМЯ_ПАКЕТА
	#Помимо указанного пакета, будут удалены все пакеты зависимые от него пакеты.

!!!Настройка описаний репозиториев задаётся в файле /etc/apt/sources.list

--------------------
РАБОТА С ПРОЦЕССАМИ:
--------------------
Любая программа состоит из набора файлов. Все файлы содержат в себе инструкции с набором команд, ссылок и других данных.
У каждой программы есть свой головной файл, который активирует работу программы до тех пор, пока работа с ней не будет завершена.
Процессом является выполнение набора связанных файлов системой.
Каждый процесс, выполняемый системой, имеет свой уникальный номер, величину занимаемой оперативной памяти, активное время работы.
Также некоторые процессы, могут выполнять другие процессы(подпроцессы), тем самым являясь родительскими для других процессов.

Каждый процесс может быть родительским и дочерним, кроме одного, который является родительским для всех.
Этот процесс всегда имеет ID номер 1 и инициирует запуск остальных процессов или перезапуск в случае сбоя.
В системе macOs этот процесс называется launchd (в linux это процесс init или systemd в более поздних версиях).

Процессы могут находиться в нескольких состояниях:

- Работающее состояние - код процесса выполняется в текущий момент.
- Спящее состояние - процесс приостановлен в ожидании какого-либо события (нажатие клавиши, ввод команды и т.д.).
- Состояние зобми - процесс завершен, данные выгружены из оперативной памяти, но запись в таблице процессов осталась.

Любой процесс в системе обладает своим приоритетом.
Приоритезация процессов нужна, чтобы распределять нагрузку на процессор.
В системах Linux и Unix существует 40 уровней приоритетов: от -20(самый низкий) до 19(наивысший). 
По умолчанию от обычного пользователя все процессы запускаются с приоритетом 0.
Расставив уровни приоритетов, мы можем управлять очередностью выполнения нескольких процессов. 

Сигналы завершения процессов:

	- SIGINT		Сигнал посылается ядром всем процессам при нажатии клавиши прерывания (CTRL+C)
	- SIGQUIT	Сигнал посылается всем процессам текущей группы при нажатии клавиш CTRL+\
	- SIGABRT	Сигнал отправляется, если процесс вызывает системный вызов abort()
	- SIGKILL	Сигнал, при получении которого выполнение процесса прекращается.
				Этот сигнал нельзя не перехватить, не проигнорировать.
	- SIGTERM	Сигнал обычно представляет своего рода предупреждение, что процесс вскоре будет уничтожен.
				Этот сигнал позволяет процессу соответствующим образом "подготовиться к смерти"
					- удалить временные файлы, завершить необходимые транзакции и т.д.
					Команда kill по умолчанию отправляет именно этот сигнал.
	- SIGSTOP	Или просто - STOP. Приостанавливает процесс, отправляя его в фон. Для вызова из фона используется команда - fg



*** ps			#статус процессов;

	Информация выводимая о процессах:
	---------------------------------
		- PID:		#Идентификатор процесса;
		- TTY:		#Терминал из которого запущен процесс;
		- TIME:		#Время работы;
		- CMD:		#Имя команды, запустившей процесс.

	-p PID		#вывести информацию о конкретной процессе;
	-a		#вывести все процессы, кроме руководителей сеансов и процессов, не связанных с терминалом
				Данная опция отображает процессы, связанные не только с вашим пользователем.
				В итоговой таблице добавляется поле STAT, которое сообщает состояние,
					в котором находится данный процесс (R - процесс выполняется в данный момент, S - процесс ожидает менее 20 секунд)
				При использовании "ps a", вы можете обнаружить некоторые процессы, запущенные суперпользователем;
	-u		#получить конкретику по пользователям, от которых запущены процессы;
	-x		#получить информацию о процессах, которые не связанны с текущим терминалом;
	-f		#отобразить связи процессов;
	-l		#отобразит информацию о приоритетах (графа "NI)";
	
	!!!Можно использовать с grep!!!



*** lost			#Ресурсы занятые процессами (в. ч. - сокеты и порты);
	lsof -i -P | grep ssh
	lsof -i tcp:22


*** /proc/		#Подробные сведения о процессе;

#Примеры использования /proc/PID

#Подробный вывод статуса:
	cat /proc/PID/status

#Адрес в ячейках оперативной памяти, которые занял процесс:
	cat /proc/PID/syscall

#Команда, которой был запущен процесс:
	cat /proc/PID/cmdline

#Символьная ссылка на рабочий каталог процесса:
	ll /proc/PID/cwd

#Символьная ссылка на исполняемый файл, запустивший процесс:
	ll /proc/PID/exe

#Увидеть ссылки на дескрипторы открытых файлов, которые затрагивает процесс:
	ll /proc/PID/fd/


*** top			#Отобразить процессы Linux;

*** nice	<ИМЯ_ПРОЦЕССА>		#запустить программу с указанным приоритетом исполнения (без ключей = 10);
	-n <УРОВЕНЬ_ПРИВЕЛЕГИЙ>	#указать с каким уровнем привилегий запустить процесс

*** renice <ИМЯ_ПРОЦЕССА>		#сменить уровень приоритета выполнения процесса
	-n <УРОВЕНЬ_ПРИВЕЛЕГИЙ>
	-p <PID>

*** kill -s <SIGNAL> <PID>	#Послать сигнал завершения (см. выше) процессу. 


-----------------------------------
АВТОМАТИЗАЦИЯ (ПЛАНИРОВАНИЕ) ЗАДАЧ:
-----------------------------------

*** crontab				#планировщик задач, позволяющий выставлять очередь задач для автоматического выполнения в определенное время.
	-l				#выведет содержимое вашего файла с расписанием - для проверки.
	-r				#удаление расписания;
	-e				#открытие конфигурационного файла на заполнение;

Шаблон заполнения:
		# Выполнять задание раз в час в 0 минут
		0 */1 * * * /home/www/myscript.sh

Первые пять параметров отвечают за время:

	минуты		0-59
	часы		0-23
	день месяца	1-31
	месяц		1-12
	день недели	0-7 (0-Вс, 1-Пн, 2-Вт, 3-Ср, 4-Чт, 5-Пт, 6-Сб, 7-Вс)


* означает любую цифру.
Числа записанные через запятую - дискретное множество значений,
Числа через дефис - диапазон значений. 

После временных значений следует путь до исполняемого скрипта.

!!!если вы собираетесь запускать скрипты на языках, для которых требуется интерпретатор (например python),
	то перед указанием файла, необходимо прописать путь до интерпретатора!!!

	*/10 * * * * /usr/bin/python script.py
	
	На примере выше утилита будет запускать скрипт каждые 10 минут.

---------------
РАБОТА С СЕТЬЮ:
---------------

Доступность соединений по сети:
-------------------------------

*** ping			#Выполняет передачу определенного пакета другой системе сети. Служит для диагностики соединений;
	ip_имя

*** traceroute		#Позволяет выполнять исследования топологии сети (получает-выдает информацию о конечных узлах сети);
	ip_имя_хоста


Проверка доступности портов
---------------------------

*** nc			#Объединение и перенаправление сокетов;

#Общий синтаксис для nc (netcat):
	nc [-options] [HostName or IP] [PortNumber]

#Например:
	nc -zvw3 192.168.1.8 22


Проверка используемых портов:
-----------------------------

*** ss			#Еще одна утилита исследования сокетов;

#Примеры:
	ss -tnlp | grep ssh
	ss -tnlp | grep ":22"

#где:
	PID		#идентификатор процесса;
	USER		#имя учетной записи, от которой запущен процесс;
	PR		#приоритет процесса;
	NI		#приоритет, выставленной командой nice;
	VIRT		#объем виртуальной памяти, потребляемый процессом;
	RES		#объем используемой оперативной памяти;
	SHR		#количество разделяемой памяти, которое используется процессом;
	S		#состояние процесса;
	%CPU		#процент использования процессорного времени;
	%MEM		#потребление оперативной памяти в процентах;
	TIME		#использование процессорного времени в секундах;
	COMMAND		#команда, которая запустила процесс;


Работа с DNS:
-------------

*** host			#Возвращает информацию об узле выполняя поиск в DNS по имени или IP-адресу;
	имя_сайта/хоста

*** nslookup		#Выполняет поиск имени узла по IP;
	ip_адрес


Отслеживание трафика:
---------------------

*** finger		#Возвращает информацию о пользователях сети;


Удаленное взаимодействие по сети:
---------------------------------

*** ssh			#утилита для удаленного защищенного подключения к другой системе.
				##С помощью данного подключения можно вводить команды управления оболочкой другой системы.
	sudo apt install ssh			#установить пакет ssh;
	ssh-keygen				#генерация пары (приватного и публичного) ключей ssh для удаленного подключения по 22 порту;
		-t rsa				#указывает тип создаваемого ключа; в данном случае создается ключ в формате RSA;
	ssh-add	<ПУТЬ_ДО_SSH_PRIVATE_KEY>	#передает путь до ключа и пароль (если требуется) SSH-агенту в текущем сеансе
							##для автоматического  подключения по ssh;

*** ftp			#утилита для передачи данных другой системе.

*** wget			#неинтерактивная утилита для скачивания файлов с сайтов.

*** curl			#утилита для скачивания и передачи файлов, поддерживающая следующие протоколы:
				DICT, FILE, FTP, FTPS, GOPHER, HTTP, HTTPS, IMAP, IMAPS, LDAP, LDAPS, POP3, 
					POP3S,  RTMP, RTSP,  SCP, SFTP, SMB, SMBS, SMTP, SMTPS, TELNET и TFTP.
			#Данная утилита имеет очень много полезных опций, с ее помощью можно скачивать файлы, используя прокси сервер.
				#Помимо файлов, данной командой можно получить заголовки от сервера и его статус или информацию о том,
					какой веб сервер используется.
	http://ссылка_на_файл
	-O		#сохранить файл с тем же именем;
	-o		#сменить имя;
	-h		#получить справку об утилите;
